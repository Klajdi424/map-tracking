<!DOCTYPE html>
<html>
<head>
  <title>Map Tracking</title>
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { height: 100%; width: 100%; }
    #loading {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      text-align: center;
      z-index: 1000;
    }
    #loading p {
      margin-top: 40%;
      font-size: 20px;
      color: #333;
    }
  </style>
</head>
<body>
  <div id="loading">
    <p>Loading...</p>
  </div>
  <div id="map"></div>
  <script>
    // Initialize variables
    let map;
    let driverMarker;
    let routeLayers = {};
    let lastDriverRoutePos = {};
    const threshold = 0.0001;

    // Default fallback center (New York City)
    const defaultCenter = [40.748817, -73.985428];
    const defaultZoom = 13;

    // Show loading indicator
    function showLoading() {
      document.getElementById('loading').style.display = 'block';
    }

    // Hide loading indicator
    function hideLoading() {
      document.getElementById('loading').style.display = 'none';
    }

    // Check if the driver has moved enough
    function hasMovedEnough(oldPos, newPos, th) {
      if (!oldPos) return true;
      return (Math.abs(oldPos[0] - newPos[0]) > th) || (Math.abs(oldPos[1] - newPos[1]) > th);
    }

    // Fetch and display a route between two points
    function getRoute(start, end, color, key) {
      showLoading();
      fetch(`https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=simplified&geometries=geojson`)
        .then(response => response.json())
        .then(data => {
          if (routeLayers[key]) {
            map.removeLayer(routeLayers[key]);
          }
          routeLayers[key] = L.geoJSON(data.routes[0].geometry, {
            style: { color: color, weight: 6 }
          }).addTo(map);

          // Fit bounds to the route
          const routeBounds = L.geoJSON(data.routes[0].geometry).getBounds();
          map.fitBounds(routeBounds, { padding: [50, 50] });
        })
        .catch(error => console.error("Error fetching route:", error))
        .finally(() => {
          hideLoading();
        });
    }

    // Update the driver's location and route dynamically
    function updateDriverLocation(pickup, dropoff) {
      const params = new URLSearchParams(window.location.search);
      const newDriver = params.has("driverLat") && params.has("driverLng")
        ? [parseFloat(params.get("driverLat")), parseFloat(params.get("driverLng"))]
        : null;

      if (!newDriver) return;

      if (driverMarker) {
        driverMarker.setLatLng(newDriver);
      }

      if (dropoff && !pickup) {
        if (hasMovedEnough(lastDriverRoutePos["driverToDropoff"], newDriver, threshold)) {
          getRoute(newDriver, dropoff, "purple", "driverToDropoff");
          lastDriverRoutePos["driverToDropoff"] = newDriver;
        }
      } else if (pickup && !dropoff) {
        if (hasMovedEnough(lastDriverRoutePos["driverToPickup"], newDriver, threshold)) {
          getRoute(newDriver, pickup, "purple", "driverToPickup");
          lastDriverRoutePos["driverToPickup"] = newDriver;
        }
      }
    }

    // Initialize the map
    function initMap() {
      showLoading();

      const params = new URLSearchParams(window.location.search);

      const driver = params.has("driverLat") && params.has("driverLng") 
        ? [parseFloat(params.get("driverLat")), parseFloat(params.get("driverLng"))] 
        : null;
      const pickup = params.has("pickupLat") && params.has("pickupLng") 
        ? [parseFloat(params.get("pickupLat")), parseFloat(params.get("pickupLng"))] 
        : null;
      const dropoff = params.has("dropoffLat") && params.has("dropoffLng") 
        ? [parseFloat(params.get("dropoffLat")), parseFloat(params.get("dropoffLng"))] 
        : null;

      // Initialize the map with a default center
      map = L.map("map").setView(driver || pickup || dropoff || defaultCenter, defaultZoom);

      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Add markers
      if (pickup) {
        L.marker(pickup, { icon: getIcon("https://raw.githubusercontent.com/Klajdi424/image/main/pickup2.png") }).addTo(map);
      }
      if (dropoff) {
        L.marker(dropoff, { icon: getIcon("https://raw.githubusercontent.com/Klajdi424/image/main/nobackround.png") }).addTo(map);
      }
      if (driver) {
        driverMarker = L.marker(driver, { icon: getIcon("https://raw.githubusercontent.com/Klajdi424/image/main/driver.png") }).addTo(map);
      }

      // Add routes if parameters are provided
      if (driver && pickup && !dropoff) {
        getRoute(driver, pickup, "purple", "driverToPickup");
        lastDriverRoutePos["driverToPickup"] = driver;
      } else if (driver && dropoff && !pickup) {
        getRoute(driver, dropoff, "purple", "driverToDropoff");
        lastDriverRoutePos["driverToDropoff"] = driver;
      } else if (pickup && dropoff && !driver) {
        getRoute(pickup, dropoff, "purple", "pickupToDropoff");
      }

      hideLoading();
    }

    // Create a Leaflet icon
    function getIcon(url) {
      return L.icon({
        iconUrl: url,
        iconSize: [40, 40] // Smaller icon size for better performance
      });
    }

    // Initialize the map on page load
    document.addEventListener("DOMContentLoaded", initMap);
  </script>
</body>
</html>
